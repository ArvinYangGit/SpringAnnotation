Shared libraries（共享库） / runtimes pluggability（运行时插件能力）

1.Servlet容器(例如Tomcat)启动会扫描当前应用里面每一个jar包里面的ServletContainerInitializer的实现。
2.ServletContainerInitializer的实现类必须绑定在jar包里面的META-INF/services/javax.servlet.ServletContainerInitializer文件中。
文件的内容就是ServletContainerInitializer实现类的全类名。

总结：容器在启动应用的时候，会扫描当前应用每一个jar包里面的META-INF/services/javax.servlet.ServletContainerInitializer指定的
实现类，启动并运行这个实现类的方法，且会传入感兴趣的类型（即@HandlesTypes的value属性中传入的类型的后台）。

========================================================================================================================

    【Servlet同步请求】
    在Servlet 3.0之前，由于不支持异步请求，所以Servlet处理请求的逻辑是这样的：
    在Servlet容器中维护了一个主线程池，每接收到一个请求线程池就会用一个空闲的线程去完成该请求的业务请求。
但是由于线程池的线程的数量是有限制的，因此当线程池中没有空闲线程的时候，再有请求发过来用户只能等待。

    【Servlet异步请求】
    在Servlet 3.0之后，支持了异步处理请求，我们以一个例子来讲解Servlet异步请求的好处，
见cn.rain.character3.servlet.AsyncServlet，我们先来看这个例子在控制台的输出结果，其中主线程是接收请求的线程，
副线程是处理业务逻辑的请求：

    主线程开始...http-nio-8080-exec-1，开始时间为 --> 1524311280233
    主线程结束...http-nio-8080-exec-1，结束时间为 --> 1524311280237
    副线程开始...http-nio-8080-exec-2，开始时间为 --> 1524311280237
    http-nio-8080-exec-2 【业务正在处理中....】
    副线程结束...http-nio-8080-exec-2，结束时间为 --> 1524311283240

    通过运行结果，我们可以知道以下几点：
    （1）主线程和副线程使用的不是同一条线程。
    （2）主线程会迅速执行完成，然后副线程会将整个业务流程执行完。

    通过以上两点，我们来说异步请求的好处，之前不支持异步请求的时候，从接收请求到处理业务逻辑，都是线程池某一条
线程单独完成，因此这样就造成一个隐患，一旦请求量过大线程池中没有空闲线程，那么便不能再接受请求。
    但是有了异步处理以后我们看到，接受请求和处理业务使用的线程不再是同一条线程，这是因为Servlet容器中维护了两个
线程池，主线程池专门用来接收请求，接收到请求以后如果发现是异步处理，那么该条线程立即返回，随即又称为空闲状态可以
接收其他请求，而该请求的业务逻辑从另一个异步处理线程池中拿出一条线程来处理业务逻辑，这样做大大提高了接收大量请求的
能力。

